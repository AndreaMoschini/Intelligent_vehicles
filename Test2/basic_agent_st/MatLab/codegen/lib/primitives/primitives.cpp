//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: primitives.cpp
//
// MATLAB Coder version            : 24.2
// C/C++ source code generated on  : 27-Nov-2024 16:53:14
//

// Include Files
#include "primitives.h"
#include "rt_nonfinite.h"
#include <cmath>

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions
//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else {
    double d;
    y = std::abs(u0);
    d = std::abs(u1);
    if (std::isinf(u1)) {
      if (y == 1.0) {
        y = 1.0;
      } else if (y > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d == 0.0) {
      y = 1.0;
    } else if (d == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }
  return y;
}

//
// A_OPT
//     OUT1 = A_OPT(t,V0,A0,SF,VF,AF,T)
//
// Arguments    : double t
//                double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
// Return Type  : double
//
double a_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1;
  double out1_tmp;
  double t3;
  double t4;
  double t4_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:28
  out1 = T * T;
  t3 = af * out1;
  t4_tmp = a0 * out1;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return ((a0 - 1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 3.0) *
                    ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                     t4_tmp) *
                    10.0) +
          t * t / (out1 * out1) *
              ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
               b_out1_tmp * 14.0) *
              6.0) -
         1.0 / rt_powd_snf(T, 3.0) * t *
             ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) + b_out1_tmp * 8.0) *
             3.0;
}

//
// COEF_LIST
//     COEF_LIST_VAR = COEF_LIST(V0,A0,SF,VF,AF,T)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
//                double coef_list_var[6]
// Return Type  : void
//
void coef_list(double v0, double a0, double sf, double vf, double af, double T,
               double coef_list_var[6])
{
  double b_coef_list_var_tmp;
  double coef_list_var_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:28
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  coef_list_var[0] = 0.0;
  coef_list_var[1] = v0;
  coef_list_var[2] = a0;
  coef_list_var_tmp = T * v0;
  b_coef_list_var_tmp = T * vf;
  coef_list_var[3] = 1.0 / rt_powd_snf(T, 3.0) *
                     ((((sf * -20.0 + t4) - t3) + coef_list_var_tmp * 12.0) +
                      b_coef_list_var_tmp * 8.0) *
                     -3.0;
  coef_list_var[4] =
      1.0 / (t2 * t2) *
      ((((sf * -30.0 - t3 * 2.0) + t4) + coef_list_var_tmp * 16.0) +
       b_coef_list_var_tmp * 14.0) *
      12.0;
  coef_list_var[5] = 1.0 / rt_powd_snf(T, 5.0) *
                     ((((sf * -12.0 - t3) + coef_list_var_tmp * 6.0) +
                       b_coef_list_var_tmp * 6.0) +
                      t4_tmp) *
                     -60.0;
}

//
// FINAL_OPT_POS_STOP_ZERO_JERK
//     FINAL_OPT_POS_STOP_ZERO_JERK_VAR = FINAL_OPT_POS_STOP_ZERO_JERK(V0,A0,T)
//
// Arguments    : double v0
//                double a0
//                double T
// Return Type  : double
//
double final_opt_pos_stop_zero_jerk(double v0, double a0, double T)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:10:32
  return T * v0 * 0.6 + T * T * a0 * 0.15;
}

//
// FINAL_OPT_TIME_PASS
//     OUT1 = FINAL_OPT_TIME_PASS(V0,A0,SF,VF)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double vf
// Return Type  : double
//
double final_opt_time_pass(double v0, double a0, double sf, double vf)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:44:22
  return sf * 30.0 /
         ((v0 * 7.0 + vf * 8.0) +
          std::sqrt(((a0 * sf * 60.0 + v0 * vf * 112.0) + v0 * v0 * 49.0) +
                    vf * vf * 64.0));
}

//
// FINAL_OPT_TIME_PASS_ZERO_JERK
//     FINAL_OPT_TIME_PASS_ZERO_JERK_VAR =
//     FINAL_OPT_TIME_PASS_ZERO_JERK(V0,A0,SF)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double final_opt_time_pass_zero_jerk_var[2]
// Return Type  : void
//
void final_opt_time_pass_zero_jerk(double v0, double a0, double sf,
                                   double final_opt_time_pass_zero_jerk_var[2])
{
  double t2;
  double t9;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:44:19
  t2 = v0 * 5.0;
  t9 = 2.23606797749979 * std::sqrt(a0 * sf * 8.0 + t2 * v0);
  final_opt_time_pass_zero_jerk_var[0] = sf * 10.0 / (t2 + t9);
  final_opt_time_pass_zero_jerk_var[1] = sf * 10.0 / (t2 - t9);
}

//
// FINAL_OPT_TIME_STOP
//     OUT1 = FINAL_OPT_TIME_STOP(V0,A0,SF)
//
// Arguments    : double v0
//                double a0
//                double sf
// Return Type  : double
//
double final_opt_time_stop(double v0, double a0, double sf)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:42
  return sf * 10.0 / (v0 * 2.0 + std::sqrt(a0 * sf * 5.0 + v0 * v0 * 4.0));
}

//
// FINAL_OPT_TIME_STOP_ZERO_JERK
//     OUT1 = FINAL_OPT_TIME_STOP_ZERO_JERK(V0,A0)
//
// Arguments    : double v0
//                double a0
// Return Type  : double
//
double final_opt_time_stop_zero_jerk(double v0, double a0)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:10:32
  return v0 * -2.0 / a0;
}

//
// FINAL_OPT_VEL_PASS
//     FINAL_OPT_VEL_PASS_VAR = FINAL_OPT_VEL_PASS(V0,A0,SF,T)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double T
// Return Type  : double
//
double final_opt_vel_pass(double v0, double a0, double sf, double T)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:44:22
  return ((sf * -15.0 + T * v0 * 7.0) + T * T * a0) * -0.125 / T;
}

//
// FINAL_OPT_VEL_PASS_ZERO_JERK
//     FINAL_OPT_VEL_PASS_ZERO_JERK_VAR =
//     FINAL_OPT_VEL_PASS_ZERO_JERK(V0,A0,SF,T)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double T
// Return Type  : double
//
double final_opt_vel_pass_zero_jerk(double v0, double a0, double sf, double T)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:44:19
  return ((sf * -20.0 + T * v0 * 12.0) + T * T * a0 * 3.0) * -0.125 / T;
}

//
// J_OPT
//     OUT1 = J_OPT(t,V0,A0,SF,VF,AF,T)
//
// Arguments    : double t
//                double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
// Return Type  : double
//
double j_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1;
  double out1_tmp;
  double t3;
  double t4;
  double t4_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:28
  out1 = T * T;
  t3 = af * out1;
  t4_tmp = a0 * out1;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (1.0 / rt_powd_snf(T, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              -3.0 -
          1.0 / rt_powd_snf(T, 5.0) * (t * t) *
              ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
               t4_tmp) *
              30.0) +
         t / (out1 * out1) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             12.0;
}

//
// Arguments    : double v0
//                double a0
//                double sf
//                double vfmin
//                double vfmax
//                double Tmin
//                double Tmax
//                double coeffsT2[6]
//                double *v2
//                double *T2
//                double coeffsT1[6]
//                double *v1
//                double *T1
// Return Type  : void
//
void pass_primitive(double v0, double a0, double sf, double vfmin, double vfmax,
                    double Tmin, double Tmax, double coeffsT2[6], double *v2,
                    double *T2, double coeffsT1[6], double *v1, double *T1)
{
  double Tstar;
  double vfminStar;
  //
  //            Agent Logic
  //          Pass Primitive
  //               2024
  //
  if (a0 >= 0.0) {
    vfminStar = final_opt_time_pass(v0, a0, sf, vfmax);
    Tstar = final_opt_time_pass(v0, a0, sf, vfmin);
  } else {
    Tstar = time_min_vel(a0, sf);
    vfminStar = final_opt_vel_pass(v0, a0, sf, Tstar);
    if ((vfminStar < vfmin) && (vfminStar < vfmax)) {
      vfminStar = final_opt_time_pass(v0, a0, sf, vfmax);
      Tstar = final_opt_time_pass(v0, a0, sf, vfmin);
    } else if ((vfmin < vfminStar) && (vfminStar < vfmax)) {
      vfminStar = final_opt_time_pass(v0, a0, sf, vfmax);
    } else {
      vfminStar = 0.0;
      Tstar = 0.0;
    }
  }
  if ((Tmin == 0.0) && (Tmax == 0.0)) {
    *T1 = vfminStar;
    *T2 = Tstar;
  } else {
    *T1 = std::fmax(vfminStar, Tmin);
    *T2 = std::fmin(Tstar, Tmax);
  }
  if ((vfminStar != 0.0) && (vfminStar <= Tstar) && (*T1 <= *T2)) {
    *v1 = final_opt_vel_pass(v0, a0, sf, *T1);
    *v2 = final_opt_vel_pass(v0, a0, sf, *T2);
    coef_list(v0, a0, sf, *v1, 0.0, *T1, coeffsT1);
    coef_list(v0, a0, sf, *v2, 0.0, *T2, coeffsT2);
  } else {
    for (int i{0}; i < 6; i++) {
      coeffsT1[i] = 0.0;
      coeffsT2[i] = 0.0;
    }
    *T1 = 0.0;
    *T2 = 0.0;
    *v1 = 0.0;
    *v2 = 0.0;
  }
}

//
// Arguments    : double v0
//                double a0
//                double sf
//                double vfmin
//                double vfmax
//                double coefsj0[6]
//                double *vfj0
//                double *tfj0
// Return Type  : void
//
void pass_primitive_j0(double v0, double a0, double sf, double vfmin,
                       double vfmax, double coefsj0[6], double *vfj0,
                       double *tfj0)
{
  double tempp[2];
  //
  //           Agent Logic
  //          Pass Primitive J0
  //               2024
  //
  final_opt_time_pass_zero_jerk(v0, a0, sf, tempp);
  *vfj0 = final_opt_vel_pass_zero_jerk(v0, a0, sf, tempp[0]);
  if ((vfmin < *vfj0) && (vfmax > *vfj0)) {
    coef_list(v0, a0, sf, *vfj0, 0.0, tempp[0], coefsj0);
    *tfj0 = tempp[0];
  } else {
    final_opt_time_pass_zero_jerk(v0, a0, sf, tempp);
    *vfj0 = final_opt_vel_pass_zero_jerk(v0, a0, sf, tempp[1]);
    if ((vfmin < *vfj0) && (vfmax > *vfj0)) {
      coef_list(v0, a0, sf, *vfj0, 0.0, tempp[1], coefsj0);
      *tfj0 = tempp[1];
    } else {
      for (int i{0}; i < 6; i++) {
        coefsj0[i] = 0.0;
      }
      *vfj0 = 0.0;
      *tfj0 = 0.0;
    }
  }
}

//
// Arguments    : void
// Return Type  : void
//
void primitives_initialize()
{
}

//
// Arguments    : void
// Return Type  : void
//
void primitives_terminate()
{
}

//
// S_OPT
//     OUT1 = S_OPT(t,V0,A0,SF,VF,AF,T)
//
// Arguments    : double t
//                double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
// Return Type  : double
//
double s_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1;
  double out1_tmp;
  double t3;
  double t4;
  double t4_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:27
  out1 = T * T;
  t3 = af * out1;
  t4_tmp = a0 * out1;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((t * v0 + a0 * (t * t) / 2.0) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 5.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) /
               2.0) -
          1.0 / rt_powd_snf(T, 3.0) * rt_powd_snf(t, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) /
              2.0) +
         rt_powd_snf(t, 4.0) / (out1 * out1) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) /
             2.0;
}

//
// Arguments    : double v0
//                double a0
//                double sf
//                double coefs[6]
//                double *maxsf
//                double *tf
// Return Type  : void
//
void stop_primitive(double v0, double a0, double sf, double coefs[6],
                    double *maxsf, double *tf)
{
  //
  //           Agent Logic
  //          Stop Primitive
  //               2024
  //
  if (v0 > 0.0) {
    double d;
    *maxsf = sf;
    d = 4.0 * (v0 * v0);
    if (d + 5.0 * a0 * sf < 0.0) {
      *maxsf = -(d / (5.0 * a0));
      *tf = 5.0 * *maxsf / v0;
    } else {
      *tf = final_opt_time_stop(v0, a0, sf);
    }
    coef_list(v0, a0, *maxsf, 0.0, 0.0, *tf, coefs);
  } else {
    *maxsf = 0.0;
    *tf = 0.0;
    for (int i{0}; i < 6; i++) {
      coefs[i] = 0.0;
    }
  }
}

//
// Arguments    : double v0
//                double a0
//                double coefsj0[6]
//                double *sfj0
//                double *tfj0
// Return Type  : void
//
void stop_primitive_j0(double v0, double a0, double coefsj0[6], double *sfj0,
                       double *tfj0)
{
  //
  //            Agent Logic
  //          Stop Primitive J0
  //               2024
  //
  if ((v0 > 0.0) && (a0 < 0.0)) {
    *tfj0 = final_opt_time_stop_zero_jerk(v0, a0);
    *sfj0 = final_opt_pos_stop_zero_jerk(v0, a0, *tfj0);
    coef_list(v0, a0, *sfj0, 0.0, 0.0, *tfj0, coefsj0);
  } else {
    *tfj0 = 0.0;
    *sfj0 = 0.0;
    for (int i{0}; i < 6; i++) {
      coefsj0[i] = 0.0;
    }
  }
}

//
// TIME_MIN_VEL
//     OUT1 = TIME_MIN_VEL(A0,SF)
//
// Arguments    : double a0
//                double sf
// Return Type  : double
//
double time_min_vel(double a0, double sf)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:44:22
  return -(3.872983346207417 * std::sqrt(-a0 * sf)) / a0;
}

//
// TOTAL_COST
//     TOTAL_COST_VAR = TOTAL_COST(V0,A0,SF,VF,AF,T)
//
// Arguments    : double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
// Return Type  : double
//
double total_cost(double v0, double a0, double sf, double vf, double af,
                  double T)
{
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:28
  return 1.0 / rt_powd_snf(T, 5.0) *
         ((((rt_powd_snf(T, 3.0) *
                 (((a0 * v0 * 72.0 + a0 * vf * 48.0) - af * v0 * 48.0) -
                  af * vf * 72.0) +
             T * T *
                 ((((a0 * sf * -120.0 + af * sf * 120.0) + v0 * vf * 336.0) +
                   v0 * v0 * 192.0) +
                  vf * vf * 192.0)) +
            sf * sf * 720.0) +
           rt_powd_snf(T, 4.0) *
               ((a0 * af * -6.0 + a0 * a0 * 9.0) + af * af * 9.0)) -
          T * sf * (v0 + vf) * 720.0);
}

//
// V_OPT
//     OUT1 = V_OPT(t,V0,A0,SF,VF,AF,T)
//
// Arguments    : double t
//                double v0
//                double a0
//                double sf
//                double vf
//                double af
//                double T
// Return Type  : double
//
double v_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1;
  double out1_tmp;
  double t3;
  double t4;
  double t4_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 24.2.
  //     27-Nov-2024 16:05:27
  out1 = T * T;
  t3 = af * out1;
  t4_tmp = a0 * out1;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (out1 * out1) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

//
// File trailer for primitives.cpp
//
// [EOF]
//
